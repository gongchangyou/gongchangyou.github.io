<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Mouse的博客</title>
		<description>记录学习生活工作的点滴</description>
		<link>http://localhost:4000</link>
		<atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
		
			<item>
				<title>Validation</title>
				<description>&lt;h1 id=&quot;validation&quot;&gt;Validation&lt;/h1&gt;

&lt;p&gt;代码仓库:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/gongchangyou/pdfreader&quot;&gt;https://github.com/gongchangyou/pdfreader&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;dependency&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-validation&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-aspects&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;annotation&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface ParamValidation {
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;aspect&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Slf4j
@Component
@Aspect
@Order(10)
public class ValidationAspect {

    @Autowired
    @Qualifier(&quot;executableValidator&quot;)
    private ExecutableValidator validator;
//    @Around(value = &quot;within(com.mouse.pdfreader.*) &amp;amp;&amp;amp; execution(public * com.mouse.pdfreader.*.*(..)) &amp;amp;&amp;amp; @annotation(com.mouse.pdfreader.aop.ParamValidation)&quot;)
    @Around(value = &quot;@annotation(paramValidation) &quot;)
    public Object process(ProceedingJoinPoint proceedingJoinPoint, ParamValidation paramValidation) {
        val sw= new StopWatch();
        sw.start(&quot;validation&quot;);
        Set&amp;lt;ConstraintViolation&amp;lt;Object&amp;gt;&amp;gt; constraintViolations = validator.validateParameters(proceedingJoinPoint.getTarget(), ((MethodSignature)proceedingJoinPoint.getSignature()).getMethod(), proceedingJoinPoint.getArgs());
        sw.stop();
        log.info(sw.prettyPrint());

        if(constraintViolations.size() &amp;gt; 0){
            final String constraintMessage = constraintViolations.stream()
                    .findFirst()
                    .map(ConstraintViolation::getMessage)
                    .orElse(&quot;&quot;);

            return constraintMessage;
        }

        try {
            return proceedingJoinPoint.proceed();
        } catch (Throwable e) {
            e.printStackTrace();
        }

        return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Config:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Configuration
public class ValidatorConfiguration {
    @Bean(name = &quot;executableValidator&quot;)
    ExecutableValidator get() {
        val validatorFactory = Validation.byProvider(HibernateValidator.class).configure().failFast(true).buildValidatorFactory();
        return validatorFactory.getValidator().forExecutables();
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Service&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Service
public class TestService {

    @ParamValidation
    public String test(@Valid ParamData param){
        return &quot;success&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;param&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Data
@Builder
public class ParamData {
    @Range(min=1,max=10, message = &quot;1-10&quot;)
    int age;

    @NotNull(message = &quot;null name&quot;)
    String name;

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;检查的字段数,1-2个字段 耗时 0.2-0.4ms。  对于高频计算来说，还是耗时较高。&lt;/p&gt;

</description>
				<pubDate>Thu, 13 Oct 2022 10:25:06 +0800</pubDate>
				<link>http://localhost:4000/2022/10/validation</link>
				<guid isPermaLink="true">http://localhost:4000/2022/10/validation</guid>
			</item>
		
			<item>
				<title>reflect</title>
				<description>&lt;h1 id=&quot;reflect&quot;&gt;reflect&lt;/h1&gt;

&lt;p&gt;反射取值的性能？&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Slf4j
@SpringBootTest
public class ReflectTest {
    @Test
    void test() {
        val a = Node.builder()
                .name(&quot;a&quot;)
                .age(10)
                .node(SubNode.builder()
                        .name(&quot;sub_a&quot;)
                        .age(5)
                        .build())
                .build();

        val b = Node.builder()
                .name(&quot;a&quot;)
                .age(10)
                .node(SubNode.builder()
                        .name(&quot;sub_a&quot;)
                        .age(6)
                        .build())
                .build();

        val sw= new StopWatch();
        sw.start();
        for(int i = 0; i &amp;lt;1000; i++) {
            for(val f : a.getClass().getDeclaredFields()) {
                f.setAccessible(true);
                try {
                    f.get(a).equals(f.get(b));
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                }
                break;
            }
                //            log.info(&quot;result={}&quot;, isEqual(a, b));
        }
        sw.stop();
        log.info(sw.prettyPrint());
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;字段数, 耗时&lt;/p&gt;

&lt;p&gt;100,  0.68ms&lt;/p&gt;

&lt;p&gt;1000, 3ms&lt;/p&gt;

&lt;p&gt;10000, 11ms&lt;/p&gt;

</description>
				<pubDate>Tue, 11 Oct 2022 10:25:06 +0800</pubDate>
				<link>http://localhost:4000/2022/10/reflect</link>
				<guid isPermaLink="true">http://localhost:4000/2022/10/reflect</guid>
			</item>
		
			<item>
				<title>xmind</title>
				<description>&lt;h1 id=&quot;xmind&quot;&gt;Xmind&lt;/h1&gt;

&lt;p&gt;利用java api 读取代码，并自动生成 xmind&lt;/p&gt;

&lt;p&gt;类的依赖关系一目了然&lt;/p&gt;

&lt;p&gt;参考文章: &lt;a href=&quot;https://juejin.cn/post/6844904012915933191&quot;&gt;https://juejin.cn/post/6844904012915933191&lt;/a&gt;
&lt;a href=&quot;https://blog.51cto.com/u_7932852/3753021&quot;&gt;https://blog.51cto.com/u_7932852/3753021&lt;/a&gt;&lt;/p&gt;
</description>
				<pubDate>Fri, 23 Sep 2022 10:25:06 +0800</pubDate>
				<link>http://localhost:4000/2022/09/xmind</link>
				<guid isPermaLink="true">http://localhost:4000/2022/09/xmind</guid>
			</item>
		
			<item>
				<title>quic</title>
				<description>&lt;h1 id=&quot;quic&quot;&gt;quic&lt;/h1&gt;

&lt;p&gt;参考文章: &lt;a href=&quot;https://zhuanlan.zhihu.com/p/270628018&quot;&gt;https://zhuanlan.zhihu.com/p/270628018&lt;/a&gt;&lt;/p&gt;

</description>
				<pubDate>Thu, 15 Sep 2022 10:25:06 +0800</pubDate>
				<link>http://localhost:4000/2022/09/quic</link>
				<guid isPermaLink="true">http://localhost:4000/2022/09/quic</guid>
			</item>
		
			<item>
				<title>spel</title>
				<description>&lt;h1 id=&quot;spel&quot;&gt;SpEL&lt;/h1&gt;

&lt;p&gt;spring 是一个支持查询和操作运行时对象导航图功能的强大的表达式语言. 它的语法类似于传统EL.&lt;/p&gt;

&lt;p&gt;参考文章: &lt;a href=&quot;http://itmyhome.com/spring/expressions.html&quot;&gt;http://itmyhome.com/spring/expressions.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6921491842865299469&quot;&gt;https://juejin.cn/post/6921491842865299469&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://spring.hhui.top/spring-blog/2020/05/18/200518-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BSpEL%E8%AF%AD%E6%B3%95%E6%89%AB%E7%9B%B2%E4%B8%8E%E6%9F%A5%E8%AF%A2%E6%89%8B%E5%86%8C/&quot;&gt;https://spring.hhui.top/spring-blog/2020/05/18/200518-SpringBoot%E7%B3%BB%E5%88%97%E4%B9%8BSpEL%E8%AF%AD%E6%B3%95%E6%89%AB%E7%9B%B2%E4%B8%8E%E6%9F%A5%E8%AF%A2%E6%89%8B%E5%86%8C/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.baeldung.com/spring-expression-language&quot;&gt;https://www.baeldung.com/spring-expression-language&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;代码仓库: &lt;a href=&quot;https://github.com/gongchangyou/spel_demo&quot;&gt;https://github.com/gongchangyou/spel_demo&lt;/a&gt;&lt;/p&gt;

</description>
				<pubDate>Tue, 13 Sep 2022 10:25:06 +0800</pubDate>
				<link>http://localhost:4000/2022/09/SpEL</link>
				<guid isPermaLink="true">http://localhost:4000/2022/09/SpEL</guid>
			</item>
		
			<item>
				<title>udp</title>
				<description>&lt;h1 id=&quot;udp-multicast&quot;&gt;Udp multicast&lt;/h1&gt;

&lt;p&gt;因为传统的tcp 在金融领域的延迟太高了（1ms)&lt;/p&gt;

&lt;p&gt;一般选择udp，再添加定制化开发一些服务的保证。&lt;/p&gt;

</description>
				<pubDate>Mon, 05 Sep 2022 10:25:06 +0800</pubDate>
				<link>http://localhost:4000/2022/09/udp</link>
				<guid isPermaLink="true">http://localhost:4000/2022/09/udp</guid>
			</item>
		
			<item>
				<title>b+tree</title>
				<description>&lt;h1 id=&quot;btree&quot;&gt;b+tree&lt;/h1&gt;

&lt;p&gt;因为 ignite 搜索后迭代效率有点低，所以找找看有没有现成的内存 B+树。&lt;/p&gt;

&lt;p&gt;开源的有btree4j 有 bug， 网上搜到的范围查询 要遍历所有节点，性能不佳，所以自行开发。&lt;/p&gt;

&lt;p&gt;代码仓库: &lt;a href=&quot;https://github.com/gongchangyou/dolphincache&quot;&gt;https://github.com/gongchangyou/dolphincache&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;参考文章: &lt;a href=&quot;https://www.cnblogs.com/zzk0/p/14656189.html&quot;&gt;https://www.cnblogs.com/zzk0/p/14656189.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html&quot;&gt;https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html&lt;/a&gt;&lt;/p&gt;
</description>
				<pubDate>Sat, 20 Aug 2022 10:25:06 +0800</pubDate>
				<link>http://localhost:4000/2022/08/b+tree</link>
				<guid isPermaLink="true">http://localhost:4000/2022/08/b+tree</guid>
			</item>
		
			<item>
				<title>ignite</title>
				<description>&lt;h1 id=&quot;ignite&quot;&gt;Ignite&lt;/h1&gt;

&lt;p&gt;试想这样一种场景，需要快速查找数据，一般我们会选择缓存，比如redis.&lt;/p&gt;

&lt;p&gt;如果想更快一点， 我们就用本地缓存，guava local cache 的 进化版本 Caffeine.&lt;/p&gt;

&lt;p&gt;但是这些都只满足kv的场景， 如果希望像mysql 那样关系型查找就不满足了。&lt;/p&gt;

&lt;p&gt;于是我想到了在内存中构建一个B+树来实现，这种很自然的想法应该有现成的轮子了。所以我找到了这个开源组件 ignite&lt;/p&gt;

&lt;p&gt;官网: &lt;a href=&quot;https://ignite.apache.org/&quot;&gt;https://ignite.apache.org/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;源码: &lt;a href=&quot;https://github.com/apache/ignite&quot;&gt;https://github.com/apache/ignite&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;获取镜像&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker search apacheignite/ignite
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;拉取镜像&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; docker pull apacheignite/ignite
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;默认情况，docker将暴露以下端口：11211, 47100, 47500, 49112&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;启动 (想要持久化 请看参考文章 这里只介绍 in memory)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run -d -p 10800:10800 apacheignite/ignite
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;代码仓库 :  &lt;a href=&quot;https://github.com/gongchangyou/ignite_test&quot;&gt;https://github.com/gongchangyou/ignite_test&lt;/a&gt;  奇怪，这里如果不启动ignite也能正常执行（上述1-3不用做)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;font color=&quot;red&quot;&gt;比对结果， 不管是筛选 long ,double, 还是String。 ignite均比内存中的list.stream().filter 都要快(换成 parallelStream 也无法提升一个数量级, 毕竟 n/threads 时间复杂度还是n, ignite有B+树， 时间复杂度是logn)&lt;/font&gt;

&lt;p&gt;&lt;img src=&quot;/images/202208/WechatIMG390.png&quot; alt=&quot;&quot; width=&quot;400&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ignite 为什么会这么快？ 除了使用B+树以外，还使用了future. 在 IgniteCacheProxyImpl 下面这个query方法中,返回的那个迭代器中，每次 onHasNext 都会去future里面get结果。所以并不是一把结果load出来.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    private &amp;lt;T, R&amp;gt; QueryCursor&amp;lt;R&amp;gt; query(ScanQuery scanQry, @Nullable IgniteClosure&amp;lt;T, R&amp;gt; transformer, @Nullable ClusterGroup grp) throws IgniteCheckedException {

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但是这样有一个问题，就是每次迭代时去 future.get 会阻塞，实际使用的时候会比list 耗时要长&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/202208/WechatIMG391.png&quot; alt=&quot;&quot; width=&quot;400&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意： 记得使用 withKeepBinary 查询， 形如&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;QueryCursor&amp;lt;Cache.Entry&amp;lt;BinaryObject, BinaryObject&amp;gt;&amp;gt; org = cache.withKeepBinary().query(
                new IndexQuery&amp;lt;BinaryObject, BinaryObject&amp;gt;(Person.class.getName())
                        .setCriteria(gt(&quot;orgId&quot;, 1L)));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意： h2的版本 要低于1.4.200 。我选择了 1.4.197&lt;/p&gt;

&lt;p&gt;参考文章: &lt;a href=&quot;https://hub.docker.com/r/apacheignite/ignite&quot;&gt;docker 启动 ignite&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/c_zyer/article/details/115546772&quot;&gt;https://blog.csdn.net/c_zyer/article/details/115546772&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://ignite.apache.org/docs/latest/key-value-api/using-cache-queries&quot;&gt;cache query&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.baeldung.com/apache-ignite&quot;&gt;https://www.baeldung.com/apache-ignite&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.ignite-service.cn/doc/java/QuickStartGuide.html#_1-5-%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%9A%84%E7%A4%BA%E4%BE%8B&quot;&gt;https://www.ignite-service.cn/doc/java/QuickStartGuide.html#_1-5-%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%9A%84%E7%A4%BA%E4%BE%8B&lt;/a&gt;&lt;/p&gt;
</description>
				<pubDate>Sat, 20 Aug 2022 10:25:06 +0800</pubDate>
				<link>http://localhost:4000/2022/08/ignite</link>
				<guid isPermaLink="true">http://localhost:4000/2022/08/ignite</guid>
			</item>
		
			<item>
				<title>scope</title>
				<description>&lt;h1 id=&quot;scope&quot;&gt;Scope&lt;/h1&gt;

&lt;p&gt;如果不想bean 创建的是单例，只需要添加 @Scope(“prototype”) 注解即可&lt;/p&gt;

</description>
				<pubDate>Wed, 03 Aug 2022 10:25:06 +0800</pubDate>
				<link>http://localhost:4000/2022/08/scope</link>
				<guid isPermaLink="true">http://localhost:4000/2022/08/scope</guid>
			</item>
		
			<item>
				<title>autowired</title>
				<description>&lt;h1 id=&quot;autowired-注入list&quot;&gt;autowired 注入list&lt;/h1&gt;

&lt;p&gt;代码仓库： &lt;a href=&quot;https://github.com/gongchangyou/spring_xml_test&quot;&gt;https://github.com/gongchangyou/spring_xml_test&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;autowired 注入list  .  按照Order中的 数字 由小到大放入 list。&lt;/p&gt;

&lt;p&gt;如果要注入map。 就 @PostConstruct, stream 将list中的元素整理成map&lt;/p&gt;

&lt;p&gt;参考文章： &lt;a href=&quot;https://cloud.tencent.com/developer/article/1420334&quot;&gt;https://cloud.tencent.com/developer/article/1420334&lt;/a&gt;&lt;/p&gt;

</description>
				<pubDate>Fri, 29 Jul 2022 10:25:06 +0800</pubDate>
				<link>http://localhost:4000/2022/07/autowired-list</link>
				<guid isPermaLink="true">http://localhost:4000/2022/07/autowired-list</guid>
			</item>
		
	</channel>
</rss>
